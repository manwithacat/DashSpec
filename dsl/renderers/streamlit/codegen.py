"""
DashSpec Code Generator

Generates Python code from DashSpec specifications with version tracking.
Generated code includes metadata about the DSL version and regeneration guidance.

DO NOT MODIFY THIS FILE MANUALLY - REGENERATE FROM DSL SPEC
Generated by: DashSpec CodeGen v1.1.0
DSL Version: 1.1.0
"""

from pathlib import Path
from typing import Any, Dict
from datetime import datetime
import hashlib


class CodeGenerator:
    """Generates Python code from DashSpec specifications"""

    def __init__(self, dsl_version: str = "1.1.0"):
        self.dsl_version = dsl_version
        self.generation_timestamp = datetime.now().isoformat()

    def generate_header(self, spec: Dict[str, Any]) -> str:
        """
        Generate file header with metadata and regeneration guidance

        Args:
            spec: DashSpec specification dict

        Returns:
            Header comment block
        """
        spec_hash = hashlib.sha256(str(spec).encode()).hexdigest()[:16]

        return f'''"""
AUTO-GENERATED CODE - DO NOT MODIFY MANUALLY

This file was automatically generated from a DashSpec specification.
Manual modifications will be lost when regenerated.

Generation Info:
    DSL Version: {self.dsl_version}
    Generated: {self.generation_timestamp}
    Spec Hash: {spec_hash}

To Regenerate:
    python -m dsl.codegen generate <spec_path> --output <output_path>

For Custom Behavior:
    1. Create a custom renderer by inheriting from the base class
    2. Override specific methods in your custom class
    3. Register custom renderers in custom_renderers.py

Example:
    from generated.dashboard_renderer import DashboardRenderer

    class CustomRenderer(DashboardRenderer):
        def render_custom_chart(self, viz, data):
            # Your custom implementation
            pass

    # Use custom renderer
    renderer = CustomRenderer(spec_path)
    renderer.render()

See: docs/customization_guide.md for details
"""

'''

    def generate_renderer_class(self, spec: Dict[str, Any], class_name: str) -> str:
        """
        Generate renderer class from specification

        Args:
            spec: DashSpec specification
            class_name: Name for the generated class

        Returns:
            Python class code
        """
        dashboard_id = spec.get("dashboard", {}).get("id", "unknown")
        dashboard_title = spec.get("dashboard", {}).get("title", "Dashboard")

        code = self.generate_header(spec)

        code += f'''
from pathlib import Path
from typing import Any, Dict, Optional
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st

from dsl.core.adapter import build_ir, execute, parse, validate


class {class_name}:
    """
    Generated renderer for: {dashboard_title}
    Dashboard ID: {dashboard_id}

    This class is auto-generated from the DashSpec specification.
    DO NOT modify this file directly - regenerate from the spec instead.

    For customizations, create a subclass and override methods:
        class Custom{class_name}({class_name}):
            def custom_method(self):
                pass
    """

    # DSL metadata
    DSL_VERSION = "{self.dsl_version}"
    GENERATED_AT = "{self.generation_timestamp}"
    DASHBOARD_ID = "{dashboard_id}"

    # Customization hooks - override these in subclasses
    CUSTOM_RENDERERS = {{}}  # chart_type -> callable
    CUSTOM_VALIDATORS = []    # list of validator functions
    CUSTOM_TRANSFORMS = []    # list of data transform functions

    def __init__(self, spec_path: str):
        """
        Initialize renderer with specification path

        Args:
            spec_path: Path to DashSpec YAML file
        """
        self.spec_path = Path(spec_path)
        self.spec = None
        self.ir = None
        self.load_spec()

    def load_spec(self):
        """Load and validate dashboard specification"""
        with open(self.spec_path) as f:
            spec_yaml = f.read()

        # Parse
        self.spec = parse(spec_yaml)

        # Validate
        violations = validate(self.spec)
        if violations:
            st.error("Dashboard specification has errors:")
            for v in violations:
                st.error(f"[{{v['code']}}] {{v['message']}}")
                st.info(f"Repair hint: {{v['repair']}}")
            st.stop()

        # Build IR
        self.ir = build_ir(self.spec)

    def render(self):
        """Render the complete dashboard"""
        dashboard = self.spec.get("dashboard", {{}})

        # Page config
        st.set_page_config(
            page_title=dashboard.get("title", "Dashboard"),
            layout="wide"
        )

        st.title(dashboard.get("title", "Dashboard"))

        if dashboard.get("description"):
            st.markdown(dashboard["description"])

        # Page navigation
        pages = dashboard.get("pages", [])

        if len(pages) > 1:
            page_titles = [p.get("title", f"Page {{i+1}}") for i, p in enumerate(pages)]
            selected_page_title = st.sidebar.selectbox("Select Page", page_titles)
            selected_page_idx = page_titles.index(selected_page_title)
        else:
            selected_page_idx = 0

        # Render selected page
        if pages:
            self.render_page(pages[selected_page_idx], selected_page_idx)

    def render_page(self, page: Dict[str, Any], page_idx: int):
        """
        Render a single page

        Override this method to customize page rendering.
        """
        st.header(page.get("title", f"Page {{page_idx + 1}}"))

        if page.get("description"):
            st.markdown(page["description"])

        # Apply custom transforms
        for transform in self.CUSTOM_TRANSFORMS:
            page = transform(page)

        # Render filters
        filter_values = {{}}
        if page.get("filters"):
            st.subheader("Filters")
            filter_cols = st.columns(min(len(page["filters"]), 3))

            for idx, filter_spec in enumerate(page["filters"]):
                col = filter_cols[idx % len(filter_cols)]
                with col:
                    filter_value = self.render_filter(filter_spec)
                    if filter_value is not None:
                        filter_values[filter_spec["id"]] = filter_value

        # Execute with filter values
        inputs = {{"filters": filter_values}}
        results = execute(self.ir, inputs)

        # Get page results
        page_results = results["pages"][page_idx]

        # Render metrics
        if page.get("metrics"):
            self.render_metrics(page, page_results)

        # Render layout
        if page.get("layout"):
            self.render_layout(page["layout"], page_results)

    def render_visualization(self, viz: Dict[str, Any], page_results: Dict[str, Any]):
        """
        Render a visualization

        Override this method to add custom chart types.
        Check CUSTOM_RENDERERS dict for registered custom renderers.
        """
        chart_type = viz.get("chart_type")

        # Check for custom renderer first
        if chart_type in self.CUSTOM_RENDERERS:
            self.CUSTOM_RENDERERS[chart_type](viz, page_results, st)
            return

        # Use generated renderer
        df = page_results["data"]

        # Apply limit
        limit = viz.get("limit")
        if limit and len(df) > limit:
            df = df.head(limit)

        # Apply sorting
        if viz.get("sort"):
            sort_field = viz["sort"].get("field")
            sort_order = viz["sort"].get("order", "asc")
            ascending = sort_order == "asc"
            if sort_field in df.columns:
                df = df.sort_values(by=sort_field, ascending=ascending)

        # Delegate to specific renderer
        if chart_type == "table":
            self._render_table(df, viz)
        elif chart_type == "histogram":
            self._render_histogram(df, viz)
        elif chart_type == "boxplot":
            self._render_boxplot(df, viz)
        elif chart_type in ["line", "bar", "scatter", "pie", "heatmap"]:
            # Legacy chart types
            self._render_legacy_chart(chart_type, df, viz)
        else:
            st.warning(f"Chart type '{{chart_type}}' not yet implemented")
            st.info("To implement custom charts, override render_visualization or register in CUSTOM_RENDERERS")

    # ===== Generated chart renderers =====

    def _render_table(self, df: pd.DataFrame, viz: Dict[str, Any]):
        """Render data table"""
        params = viz.get("params", {{}})
        columns = params.get("columns")

        if columns:
            df = df[columns]

        st.dataframe(df)

    def _render_histogram(self, df: pd.DataFrame, viz: Dict[str, Any]):
        """Render histogram"""
        roles = viz.get("roles", {{}})
        params = viz.get("params", {{}})

        x = roles.get("x") or viz.get("x_field")
        color = roles.get("color") or viz.get("color_field")

        if not x:
            st.error("Histogram requires 'x' role")
            return

        fig = px.histogram(
            df,
            x=x,
            color=color,
            nbins=params.get("bins", 30),
            log_x=params.get("log_x", False),
            log_y=params.get("log_y", False)
        )
        st.plotly_chart(fig)

    def _render_boxplot(self, df: pd.DataFrame, viz: Dict[str, Any]):
        """Render box plot"""
        roles = viz.get("roles", {{}})

        y = roles.get("y") or viz.get("y_field")
        x = roles.get("x") or roles.get("by")
        color = roles.get("color")

        if not y:
            st.error("Box plot requires 'y' role")
            return

        fig = px.box(df, x=x, y=y, color=color)
        st.plotly_chart(fig)

    def _render_legacy_chart(self, chart_type: str, df: pd.DataFrame, viz: Dict[str, Any]):
        """Render legacy chart types (v1.0 compatibility)"""
        # This maintains backward compatibility with v1.0 specs
        if chart_type == "line":
            fig = px.line(
                df,
                x=viz.get("x_field"),
                y=viz.get("y_field"),
                color=viz.get("color_field")
            )
        elif chart_type == "bar":
            fig = px.bar(
                df,
                x=viz.get("x_field"),
                y=viz.get("y_field"),
                color=viz.get("color_field")
            )
        elif chart_type == "scatter":
            fig = px.scatter(
                df,
                x=viz.get("x_field"),
                y=viz.get("y_field"),
                color=viz.get("color_field"),
                size=viz.get("size_field")
            )
        elif chart_type == "pie":
            x_field = viz.get("x_field")
            if x_field:
                pie_data = df[x_field].value_counts().reset_index()
                pie_data.columns = ["category", "count"]
                fig = px.pie(pie_data, names="category", values="count")
            else:
                st.error("Pie chart requires x_field")
                return
        elif chart_type == "heatmap":
            x_field = viz.get("x_field")
            y_field = viz.get("y_field")
            color_field = viz.get("color_field")

            if x_field and y_field and color_field:
                pivot = df.pivot_table(
                    values=color_field,
                    index=y_field,
                    columns=x_field,
                    aggfunc="mean"
                )
                fig = px.imshow(pivot)
            else:
                st.error("Heatmap requires x_field, y_field, and color_field")
                return
        else:
            st.error(f"Unknown chart type: {{chart_type}}")
            return

        st.plotly_chart(fig)

    # ===== Helper methods (can be overridden) =====

    def render_filter(self, filter_spec: Dict[str, Any]) -> Any:
        """Render filter widget - override for custom filters"""
        # ... implementation from streamlit_renderer ...
        pass  # Shortened for brevity

    def render_metrics(self, page: Dict[str, Any], page_results: Dict[str, Any]):
        """Render metrics section - override for custom metric display"""
        # ... implementation from streamlit_renderer ...
        pass  # Shortened for brevity

    def render_layout(self, layout: Dict[str, Any], page_results: Dict[str, Any]):
        """Render page layout - override for custom layouts"""
        # ... implementation from streamlit_renderer ...
        pass  # Shortened for brevity


def generate_renderer(spec_path: str, output_path: str, class_name: str = "GeneratedRenderer"):
    """
    Generate renderer code from specification

    Args:
        spec_path: Path to DashSpec YAML
        output_path: Path for generated Python file
        class_name: Name for generated class
    """
    import yaml

    with open(spec_path) as f:
        spec = yaml.safe_load(f)

    generator = CodeGenerator(spec.get("dsl_version", "1.0.0"))
    code = generator.generate_renderer_class(spec, class_name)

    with open(output_path, "w") as f:
        f.write(code)

    print(f"Generated {{output_path}} from {{spec_path}}")
    print(f"DSL Version: {{spec.get('dsl_version')}}")
    print(f"Class: {{class_name}}")


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 3:
        print("Usage: python -m dsl.codegen <spec_path> <output_path> [class_name]")
        sys.exit(1)

    spec_path = sys.argv[1]
    output_path = sys.argv[2]
    class_name = sys.argv[3] if len(sys.argv) > 3 else "GeneratedRenderer"

    generate_renderer(spec_path, output_path, class_name)
